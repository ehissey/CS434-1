
struct VertexDataInput {
	float4 vertex : POSITION;
	float3 normal : NORMAL;
	float3 color : COLOR;
	float2 texCoord : TEXCOORD0;
};

struct VertexDataOutput {
	float4 projv  : POSITION;
	float4 color : COLOR;
	float3 vertex : TEXCOORD0;
	float3 normal : TEXCOORD1;
};

struct PixelDataOutput {
	float4 color : COLOR0;
};

VertexDataOutput VertexMain(VertexDataInput vdi, uniform float4x4 modelViewProj) {
	VertexDataOutput ret;
	ret.projv = mul(modelViewProj, vdi.vertex);
	ret.color = float4(vdi.color, 1.0f);
	ret.vertex = vdi.vertex;
	ret.normal = vdi.normal;
	return ret;
}

TRIANGLE void GeometryMain(AttribArray<VertexDataOutput> tverts, uniform float4x4 modelViewProj){
	emitVertex(tverts[0]);
	emitVertex(tverts[1]);
	emitVertex(tverts[2]);

	return;
}

PixelDataOutput FragmentMain(VertexDataOutput pdi, 
	uniform float3 cameraEye, 
	uniform samplerCUBE envMap,
	uniform float3 quadV0, 
	uniform float3 quadV1, 
	uniform float3 quadV2, 
	uniform float3 quadV3,
	uniform sampler2D quadTex, 
	uniform sampler2D depthImageZ,
	uniform sampler2D depthImageRGB) {

	PixelDataOutput ret;

	ret.color = float4(-1.0f, -1.0f, -1.0f, 1.0f);

	float3 P0 = pdi.vertex; //model space vertex
	float3 N0 = normalize(pdi.normal); //normal at vertex
	float3 L = normalize(P0 - cameraEye); //vector to camera eye from vertex
	float3 V = normalize(L - 2*dot(L,N0)*N0); //reflected camera eye vector at vertex

	float3 quadN = normalize(cross(quadV2 - quadV1, quadV0 - quadV1)); //quad normal
	float t = dot(quadN, quadV1 - P0)/dot(quadN,V); //parameter to scale V to intersect quad, could be negative
	float3 P = P0 + t*V; //point of intersection with V and quad

	//Depth Image
	//todo

	if(ret.color.x == -1.0f && t > 0){ //Quad
		if(P.x >= quadV1.x && P.x <= quadV2.x && P.z >= quadV3.z && P.z <= quadV2.z){
			float2 quadTexCoords = float2((P.x - quadV2.x)/(quadV2.x-quadV1.x), (P.z - quadV2.z)/(quadV2.z-quadV3.z)) * 5.0f;

			ret.color = tex2D(quadTex, quadTexCoords);
		}
	}

	if(ret.color.x == -1.0f){ //Environment Map
		ret.color = texCUBE(envMap, V);
	}
	
	float4 diffuseColor = float4(238.0f/255.0f, 232.0f/255.0f, 170.0f/255.0f, 1.0f);
	float scaleFactor = 0.0f;

	ret.color = (1-scaleFactor) * ret.color + scaleFactor * diffuseColor;
	
	return ret;
}


